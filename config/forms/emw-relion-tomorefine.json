{
    "sections": [
        {
            "label": "Input",
            "params": [
                {
                    "label": "Compute",
                    "paramClass": "LabelParam"
                },
                {
                    "name": "gpus",
                    "label": "GPUs",                    
                    "help": "If it is a single number (N), it will represent the total number of GPUs (0..N-1). It there are multiple values, it will be the specific GPUs ID."
                },                
                {
                    "label": "Input / Reference",
                    "paramClass": "LabelParam"
                },
                {
                    "name": "relion_refine.ios",
                    "label": "Input optimisation set:",
                    "pattern": "",
                    "help": "This will be passed with a --ios argument to the executable."
                },                
                {
                    "name": "relion_refine.ref",
                    "label": "Reference map:",
                    "help": ""
                },
                {
                    "name": "relion_refine.solvent_mask",
                    "label": "Reference mask (Optional):",
                    "help": "If no mask is provided, a soft spherical mask based on the particle diameter will be used.\n\nOtherwise, provide a Spider/mrc map containing a (soft) mask with the same dimensions as the reference(s), and values between 0 and 1, with 1 being 100% protein and 0 being 100% solvent. The reconstructed reference map will be multiplied by this mask.\n\nIn some cases, for example for non-empty icosahedral viruses, it is also useful to use a second mask. For all white (value 1) pixels in this second mask the corresponding pixels in the reconstructed map are set to the average value of these pixels. Thereby, for example, the higher density inside the virion may be set to a constant. Note that this second mask should have one-values inside the virion and zero-values in the capsid and the solvent areas. To use a second mask, use the additional option --solvent_mask2, which may given in the Additional arguments line."
                },
                {
                    "name": "relion_refine.firstiter_cc",
                    "label": "Ref. map is on absolute greyscale?",
                    "paramClass": "BooleanParam",
                    "default": false,
                    "help": "Probabilities are calculated based on a Gaussian noise model, which contains a squared difference term between the reference and the experimental image. This has a consequence that the reference needs to be on the same absolute intensity grey-scale as the experimental images. RELION and XMIPP reconstruct maps at their absolute intensity grey-scale. Other packages may perform internal normalisations of the reference density, which will result in incorrect grey-scales. Therefore: if the map was reconstructed in RELION or in XMIPP, set this option to Yes, otherwise set it to No. If set to No, RELION will use a (grey-scale invariant) cross-correlation criterion in the first iteration, and prior to the second iteration the map will be filtered again using the initial low-pass filter. This procedure is relatively quick and typically does not negatively affect the outcome of the subsequent MAP refinement. Therefore, if in doubt it is recommended to set this option to No."
                },
                {
                    "name": "relion_refine.trust_ref_size",
                    "label": "Resize reference if needed?",
                    "paramClass": "BooleanParam",
                    "default": true,
                    "help": "If true, and if the input reference map (and mask) do not have the same pixel size and/or box size, then they will be re-scaled and re-boxed accordingly. If this option is set to false, then the program will die with an error if the reference does not have the correct pixel and/or box size."
                },
                {
                    "name": "relion_refine.ini_high",
                    "label": "Initial low-pass filter (A)",
                    "default": 60,
                    "paramClass": "FloatParam",
                    "help": "It is recommended to strongly low-pass filter your initial reference map. If it has not yet been low-pass filtered, it may be done internally using this option. If set to 0, no low-pass filter will be applied to the initial reference(s)."
                },
                {
                    "name": "relion_refine.sym",
                    "label": "Symmetry",
                    "default": "C1",
                    "help": "If the molecule is asymmetric, set Symmetry group to C1. Note their are multiple possibilities for icosahedral symmetry: \n * I1: No-Crowther 222 (standard in Heymann, Chagoyen & Belnap, JSB, 151 (2005) 196â€“207) \n * I2: Crowther 222 \n * I3: 52-setting (as used in SPIDER?)\n * I4: A different 52 setting \n The command 'relion_refine --sym D2 --print_symmetry_ops' prints a list of all symmetry operators for symmetry group D2. RELION uses XMIPP's libraries for symmetry operations. Therefore, look at the XMIPP Wiki for more details:  http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/WebHome?topic=Symmetry"
                }
            ]
    },
    {
            "label": "CTF/Optimization",
            "params": [
                {
                    "label": "CTF",
                    "paramClass": "LabelParam"
                },
                {
                    "name": "relion_refine.ctf",
                    "label": "Do CTF-correction?",
                    "paramClass": "BooleanParam",
                    "default": true,
                    "help": "If set to Yes, CTFs will be applied to the projections of the map. This requires that CTF information is present in the input STAR file."
                },
                {
                    "name": "relion_refine.ctf_intact_first_peak",
                    "label": "Ignore CTFs until first peak?",
                    "paramClass": "BooleanParam",
                    "default": false,
                    "help": "If set to Yes, then CTF-amplitude correction will only be performed from the first peak of each CTF onward. This can be useful if the CTF model is inadequate at the lowest resolution. Still, in general using higher amplitude contrast on the CTFs (e.g. 10-20%) often yields better results. Therefore, this option is not generally recommended: try increasing amplitude contrast (in your input STAR file) first!"
                },              
                {
                    "label": "Optimization",
                    "paramClass": "LabelParam"
                },
                {
                    "name": "relion_refine.particle_diameter",
                    "label": "Mask diameter (A)",
                    "paramClass": "FloatParam",
                    "help": ""
                },              
                {
                    "name": "relion_refine.zero_mask",
                    "label": "Mask individual particles with zeros?",
                    "paramClass": "BooleanParam",
                    "default": true,
                    "help": "If set to Yes, then in the individual particles, the area outside a circle with the radius of the particle will be set to zeros prior to taking the Fourier transform. This will remove noise and therefore increase sensitivity in the alignment and classification. However, it will also introduce correlations between the Fourier components that are not modelled. When set to No, then the solvent area is filled with random noise, which prevents introducing correlations.High-resolution refinements (e.g. ribosomes or other large complexes in 3D auto-refine) tend to work better when filling the solvent area with random noise (i.e. setting this option to No), refinements of smaller complexes and most classifications go better when using zeros (i.e. setting this option to Yes)."
                },             
                {
                    "name": "relion_refine.solvent_correct_fsc",
                    "label": "Use solvent-flattened FSCs?",
                    "paramClass": "BooleanParam",
                    "default": false,
                    "help": "If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration. This only works when a reference mask is provided on the I/O tab. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box."
                },
                {
                    "name": "relion_refine.blush",
                    "label": "Use Blush regularisation?",
                    "paramClass": "BooleanParam",
                    "default": false,
                    "help": "If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation."
                }
                
            ]
    },
    {
            "label": "Auto-sampling",
            "params": [
                {
                    "name": "relion_refine.healpix_order",
                    "label": "Initial angular sampling",
                    "paramClass": "EnumParam",
                    "choices": {
                        "0": "30 degrees",
                        "1": "15 degrees",
                        "2": "7.5 degrees",
                        "3": "3.7 degrees",
                        "4": "1.8 degrees",
                        "5": "0.9 degrees",
                        "6": "0.5 degrees",
                        "7": "0.2 degrees",
                        "8": "0.1 degrees"
                    },
                    "help": "There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.\n\n Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that."
                },
                {
                    "name": "relion_refine.offset_range",
                    "label": "Initial offset range (pix)",
                    "paramClass": "FloatParam",
                    "default": 5,
                    "help": "Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.\n\n Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that."
                },
                {
                    "name": "relion_refine.offset_step",
                    "label": "Initial offset step (pix)",
                    "paramClass": "FloatParam",
                    "default": 1,
                    "help": "Translations will be sampled with this step-size (in pixels).Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.\n\n Note that this will only be the value for the first few iteration(s): the sampling rate will be increased automatically after that."
                },
                {
                    "name": "relion_refine.auto_local_healpix_order",
                    "label": "Local search from auto-sampling",
                    "paramClass": "EnumParam",
                    "choices": {
                        "0": "30 degrees",
                        "1": "15 degrees",
                        "2": "7.5 degrees",
                        "3": "3.7 degrees",
                        "4": "1.8 degrees",
                        "5": "0.9 degrees",
                        "6": "0.5 degrees",
                        "7": "0.2 degrees",
                        "8": "0.1 degrees"
                    },
                    "help": "In the automated procedure to increase the angular samplings, local angular searches of -6/+6 times the sampling rate will be used from this angular sampling rate onwards. For most lower-symmetric particles a value of 1.8 degrees will be sufficient. Perhaps icosahedral symmetries may benefit from a smaller value such as 0.9 degrees."
                },
                {
                    "name": "relion_refine.relax_sym",
                    "label": "Relax symmetry",
                    "help": "With this option, poses related to the standard local angular search range by the given point group will also be explored. For example, if you have a pseudo-symmetric dimer A-A', refinement or classification in C1 with symmetry relaxation by C2 might be able to improve distinction between A and A'. Note that the reference must be more-or-less aligned to the convention of (pseudo-)symmetry operators. For details, see Ilca et al 2019 and Abrishami et al 2020 cited in the About dialog."
                },
                {
                    "name": "relion_refine.solvent_correct_fsc",
                    "label": "Use solvent-flattened FSCs?",
                    "paramClass": "BooleanParam",
                    "default": false,
                    "help": "If set to Yes, then instead of using unmasked maps to calculate the gold-standard FSCs during refinement, masked half-maps are used and a post-processing-like correction of the FSC curves (with phase-randomisation) is performed every iteration. This only works when a reference mask is provided on the I/O tab. This may yield higher-resolution maps, especially when the mask contains only a relatively small volume inside the box."
                },
                {
                    "name": "relion_refine.blush",
                    "label": "Use Blush regularisation?",
                    "paramClass": "BooleanParam",
                    "default": false,
                    "help": "If set to Yes, relion_refine will use a neural network to perform regularisation by denoising at every iteration, instead of the standard smoothness regularisation."
                }

            ]
    }

    ]
}